/*
 * @author D Michael Jones, 914M - acetousk
 * 
 * The ideas portrayed in this code are mainly from the following 
 * documents:
 *      Pure Pursuit            : https://github.com/team914/autolib-pdfs/blob/master/pure-pursuit.pdf
 *      Adaptive Pure Pursuit   : https://github.com/team914/autolib-pdfs/blob/master/adaptive-pure-pursuit.pdf
 *      Path Tracking           : https://github.com/team914/autolib-pdfs/blob/master/path-tracking.pdf
 *      PiLons Position Tracking: https://github.com/team914/autolib-pdfs/blob/master/pilons-position-tracking.pdf
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
#pragma once

#include "autolib/util/messages.hpp"
#include "autolib/path/pathGenerator.hpp"
#include "okapi/api.hpp"
#include <cmath>
#include <memory>
#include <utility>
#include <vector>

#define DEBUG

using namespace okapi;

namespace autolib{

class PurePursuit {
    public:
    /**
     * PurePursuit Class's Constructor
     * 
     * This is the constructor for PurePursuit. The first param is an InternalPath which should be generated by
     * PathGenerator's getPath() method. The second param is the lookaheadDistance of the Pure Pursuit algorithm.
     * 
     * @param  {std::vector<IndexedDistancePosePath>} ipaths : 
     * @param  {okapi::QLength} ilookaheadDistance           : 
     */
    PurePursuit( const std::vector<IndexedDistancePosePath> &ipaths, const okapi::QLength &ilookaheadDistance );

    /**
     * This should be run in a loop during your autonomous. The input is the x, y, and theta in global coordinates 
     * of where your robot is currently located. This can be calculated using okapi's odometry feature. To access
     * that feature go the the feature/odometry branch on github until the official release of it. It will return
     * what the requested X, Y, Yaw, radius, and length to get to the Goal Point.
     * 
     * @param  {okapi::OdomState} or {Pose} ipose : 
     * @param  {std::string} iid        : 
     * @return {PurePursuitTriangle}    : 
     */
    PurePursuitTriangle run( const okapi::OdomState &ipose, const std::string &iid );
    PurePursuitTriangle run( const Pose &ipose, const std::string &iid );

    /**
     * This should be used in a loop during your autonomous. It is static, but is meant for the PurePursuit class.
     * It is recommended to use motion profiling for the first parameter. The second parameter should be from your
     * run method from the PurePursuit class. The third method should be from you okapi's ChassisControllerBuilder.
     * 
     * Note: Using this method is optional. You can and probably should create your own controller to use the triangle
     * motor output This is only meant for users of okapi >= v4.0.0.
     * 
     * @param  {double} reqVelocity                                : 
     * @param  {PurePursuitTriangle} triangle                      : 
     * @param  {std::shared_ptr<OdomChassisController>} controller : 
     */
    static void updateChassis( const double &reqVelocity, const PurePursuitTriangle &triangle, const std::shared_ptr<OdomChassisController> &controller );

    static double findDistanceBetweenStateAndPose( const okapi::OdomState &state, const InternalPose &pose2 ){
        InternalPose pose1{ state.x.convert(meter), state.y.convert(meter), state.theta.convert(radian) };
        return findDistanceBetweenPoses( pose1, pose2 );
    }

    InternalPose getLastPoseInPath( const std::string &id ){
        for( const auto &ipath: paths ){
            if( ipath.id == id ){
                return ipath.path.at(ipath.path.size() - 1).pose;
            }
        }
    }

    protected:
    const std::vector<IndexedDistancePosePath> paths;
    IndexedDistancePosePath path;
    double avgDistanceBetweenPoses;

    IndexedDistancePosePath nearestPoses;
    PosePath currentPoses;
    IndexedPosePath goalPoses;
    std::vector<PurePursuitTriangle> triangles;

    double lookaheadDistance;

    void findPath( const std::string & );
    void findNearestPose( const Pose & );
    static double findDistanceBetweenPoses( const InternalPose &, const InternalPose & );

    void findGoalPose();
    PurePursuitTriangle findPurePursuitTriangle();
    bool isPoseWithinCircle( const InternalPose &point, const InternalPose &centerPose, const double &lookaheadDistance );

};

}//autolib
